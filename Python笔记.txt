第二章总结

2.1运算

1.数值运算

python（以下简称py）可以进行简单运算

＋ — * ／ %（取余）**（乘方）

2.逻辑运算

在计算机的二进制体系下，可以用1和0来代表‘真’和‘假’两种状态

在py中，使用True和False两个关键字表示真假。True和False这样的数据被称为布尔值(bool／Boolean).

py中用and表示‘与’运算

>>>True or True     #结果为True
>>>False and True   #结果为False 
>>>False and False  #结果为False 

用or表示‘或’运算

>>>True or True     #结果为True
>>>True and False   #结果为True
>>>False and False  #结果为False 

用not表示‘非’运算

>>>not True         #结果为False

3.判断表达式

== != < <= > >=

>>>1==1             #结果为True

4.运算优先级

乘方: **
乘除: * /
加减: + -
判断: == >= > < <= 
逻辑: and or !

相同优先级，从左至右。有高优先级先执行高优先级

2.2记忆

1.变量

命名可以由字母大小写，下划线，数字组成
首字符不能为数字

2.变量类型

数据有多种不同类型，可以将不同类型的变量赋值给同一变量，例如：

a = 5

print(a)           #a存储的内容为5

a = 'Hello world'

print(a)           #a存储的内容为字符串'Hello world'

可见，后赋予给变量的值替换了变量原来的值
py中能自由改变变量类型的特征称为动态类型（Dynamic Typing）
而在静态类型（Static Typing）语言中,变量有事先说明好的类型，特定类型数据必须存入特定类型的变量。
虽然可以随意改变，但py的变量本身还是有类型的
可以通过用type()函数来查看变量类型，例如：

a = 10

print(type(a))

输出结果为<class 'int'>

int 为整型
常见类型包括整型（int）浮点型（Float）字符串（String,简写为str）布尔值（Boolean，简写为bool）

3.序列

序列（Sequence）有两种，元组（Tuple）和列表（List）
主要区别，一旦建立，元组的各个元素不可再变更，而列表可以变更
元组和列表创建方式如下：

>>>example_tuple = (2,1.3,'love',5.6,9,12,False)   ＃一个元组
>>>example_list = [True,5,'smile']                 ＃一个列表
>>>type(example_tuple)                             ＃结果为'tuple'
>>>type(example_list)                              ＃结果为'list'

可见，同一序列可以包含不同类型数据
序列的元素不仅可以是基本类型数据，也可以是另外一个序列

>>>next_list = [1,[3,4,5]]                         ＃列表中嵌套另一个列表

由于元组不能改变数据，所以很少会建立一个空的元组
而列表可以增加和修改元素，所以py程序中经常会建立空表：

>>>empty_list = []                                 ＃空列表

序列元素的位置索引称为下标（Index）
py中序列的下标从0开始，即第一个元素下标为0，这与C语言一致

>>>example_tuple[0]       ＃结果为2
>>>example_list[2]        ＃结果为'smile'
>>>next_list[1][2]        ＃结果为5

表的元素可以变更，因此可以对单个元素进行赋值
可以通过下标说明想对哪个元素赋予怎样的值

>>>example_list[1] = 3.0
>>>example_list           ＃列表第二个元素变成3.0

元组一旦建立不可改变，不能对元组的元素进行赋值操作

对于序列，除了可以用下标来找到单个元素外，还可以通过范围引用的方式，来找多个元素
范围引用基本样式：

序列名［下限：上限：步长］

下限表示起始下标，上限表示结尾下标
在起始下标和结尾下标之间，按照步长间隔来找元素，默认步长为1
引用的多个元素将成为一个新的序列，例如：

>>>example_tuple[:5]       ＃从下标0到下标4，不包括下标5的元素
>>>example_tuple[2:]       ＃从下标2到最后一个元素
>>>example_tuple[0:5:2]    ＃下标为0，2，4的元素
>>>sliced = example_tuple[2:0:-1]     ＃从下标2到下标1
>>>type(sliced)            ＃范围引用的结果还是一个元组

y以上都是元组的例子，表的范围引用效果一致
在范围引用的时候，如果写明上限，那么这个上限下标指向的元素将不包括在结果中

此外，py还提供一种尾部引用语法，用于引用序列尾部的元素：

>>>example_tuple[-1]       ＃序列最后一个元素
>>>example_tuple[-3]       ＃序列倒数第三个元素
>>>example_tuple[1:-1]     ＃序列第二个到倒数第二个元素（上限元素不包含在结果中）

4.词典

词典很多方面与表类似，同样是一个可以容纳多个元素的容器
但词典不是以位置作为索引的，词典允许以自定义的方式来建立数据的索引

>>>example_dict = {'tom':11,'sam':57,'lily':100}
>>>type(example_dict)      ＃结果为'dict'

词典包含多个元素，每个元素以逗号分隔
词典的元素包含两个部分，键(Key)和值(Value)
键是数据的索引，值是数据本身，键和值一一对应

>>>example_dict['tom']     ＃结果为11

在词典中修改或增添一个元素的值：

>>>example_dict['tom'] = 30
>>>example_dict['lilei'] = 99
>>>example_dict            ＃结果为{'lilei': 99, 'lily': 100, 'sam': 57, 'tom': 30}

构建一个新的空词典：

>>>example_dict = {}
>>>example_dict            ＃结果为{}

词典不具备序列那样的连续有序性，所以适于存储结构松散的一组数据

在词典的例子中，以及大部分的应用场景中
我们都使用字符串作为词典的键
其它类型的数据，如数字和布尔值也可以作为词典的键
在后面会提到，哪些数据可以作为词典的键值

2.3选择

1.if结构

举个选择结构的一个简单例子
如果一个房子的售价超过五十万，那么交易费率为1%，否则为2%
用选择结构来写一个程序。

total = 980000
if total > 500000:
	transaction_rate = 0.01
else:
	transaction_rate = 0.02
print(transaction_rate)     ＃打印0.01

在这段程序中，出现if...else...语句。
如果总价超过50万，那么交易费率为1%；否则，交易费率为2%
关键字if和else分别有隶属于它们的一行代码，
从属代码的开头会有四个空格的缩进
程序最终会根据if后的条件是否成立选择是执行if的从属代码还是执行else的从属代码
if结构在程序中实现了分支
当然else也非必须，没有else实际上与空的else等价
如果if后面的条件不成立，那么计算机什么都不用执行

注意：用缩进来代表代码的从属关系，是py语言的特色
从属代码开头会有四个空格的缩进

2.if嵌套与elif

下面一个程序使用了elif结构
根据条件不同，程序有三个分支

i = 1
if i > 0:
	print('positive')
	i=i+1
elif i == 0:
	print('i is 0')
	i = i*10
else:
	print('negative')
	i = i - 1
	
这里有三个块，分别由if，elif和else引领
py先检测if的条件，如果发现if条件为假，则跳过隶属于if的程序块
检测elif的条件，如果elif的条件还是假，则执行else块
程序根据条件，只执行三个分支中的一个
由于i的值是1，所以最终只有if部分被执行
按照同样的原理，你也可以在if和else之间增加多个elif
从而给程序开出更多分支
还可以让一个if结构嵌套在另一个if结构中：

i = 5
if i > 1:
	print('i bigger than 1')
	print('good')
	if i > 2:
		print('i bigger than 2')
		print('even better')
		
在进行完第一个if判断后，如果条件成立，那么程序依次运行
会遇到第二个if结构，程序将继续根据条件判断并决定是否执行
第二个后面的程序块相对于该if又缩进了四个空格
进一步缩进的程序隶属于内层if

2.4循环

1.for循环

来看一段简单的程序

for a in [3,4.4,'life']
	print(a)          ＃依次打印列表里的每个元素
	
这个循环就是每次从列表[3,4.4,'life']中取出一个元素，然后将这个元素赋值给a
之后执行隶属于for的程序，也就是调用print()函数，把这个元素打印出来
for的基本用法：

for 元素 in 列表:
	statement
	
序列中的元素个数决定了循环重复的次数
上例中有三个元素，所以print()会执行三次
也就是说，for循环次数是确定的。
for循环会依次从序列中取出元素，赋予给紧跟在for后面的变量a
因此，尽管执行语句相同，但数据发生了变化
所以相同的语句在执行三次后的效果也会发生变化
从序列中取出元素，再赋予给一个变量并在隶属程序中使用，是for循环一个便利之处
若只想简单地重复特定的次数，不想建立序列，那么可以使用py提供的range()函数：

for i in range(5):
	print("hello world")   ＃打印五次‘hello world’
 
程序中的5向range()函数说明了需要重复的次数
因此，隶属于for的程序执行了5次 
这里，for循环后面依然有个变量i，它为每次循环起到了计数功能：
 
for i in range(5):
	print(i,'hello world')   ＃打印序号和‘hello world’	
0 hello world
1 hello world
2 hello world
3 hello world
4 hello world

可以看到，py中range()提供的计数也是从0开始的
和表的下标一样，还可以看到print()的新用法
就是在括号中说明多个变量，用逗号分开，函数print()会把它们都打印出来

再看一个for循环的实用例子
之前用元组纪录了房贷的逐年利率：

interest_tuple = (0.01,0.02,0.03,0.035,0.05)

假如有50万元的房贷，且本金不变，那么每年要还的利息有多少呢
使用for循环计算：

total = 500000
for interest in interest_tuple:
	repay = total * interest
	print('每年的利息：',repay)

每年的利息： 5000.0
每年的利息： 10000.0
每年的利息： 15000.0
每年的利息： 17500.0
每年的利息： 25000.0

2.while循环

py中还有一种循环结构，即while循环
用法：

i = 0
while i < 10:
	print(i)
	i = i + 1      ＃从0打印到9
	
while后面紧跟着一个条件
如果条件为真，则while会不停循环执行隶属于它的语句
只有条件为假时，程序才会停止
在while的隶属程序中，不断改变参与条件判断的变量i，直到它变成10
不满足条件而终止循环，这是while循环常见的做法
否则，若while条件始终为真，则会变成无限循环，例如

while True:
	print('Hello world')
	
3.跳过或终止

循环结构还提供了两个有用的语句，可以在循环结构内部使用
用于跳过或终止循环

continue           ＃跳过循环的这次执行，进行下一次的循环操作
break              ＃停止执行整个循环

例：

for i in range(10):
	if i == 2:
		continue
	print(i)       ＃打印0，1，3，4，5，6，7，8，9，跳过了2
	
当循环执行到i为2的时候，if条件成立，触发continue
不打印此时的i，程序直接进行下一次循环，把3赋值给i
继续执行for的隶属语句
continue只是跳过某次循环，而break会终止整个循环

for i in range(10):
	if i == 2:
		break
	print(i)       ＃只打印0和1
	
当循环执行到i＝2的时候，if条件成立，触发break
整个循环停止，程序不再执行for循环内部的语句

小练习

假设我可以全额贷款买房。房屋总价为50万，为了吸引购房者，
房贷前四年利率都有折扣，分别为1%，2%，3％，3.5%。
其余年份里，房贷的年利率都是5%。我逐年还款，每次最多偿还3万元。
那么，完全还清房款最少需要多少年？

i = 0
residual=500000.0
interest_tuple = (0.01,0.02,0.03,0.035)  #利率元组
repay = 30000.0
while residual > 0:
    i = i+1
    print('第',i,'年还是要还钱')
    if i <= 4:
        interest = interest_tuple[i-1]  #序列的下标从0开始
    else:
        interest = 0.05
    residual = residual*(interest + 1)-repay
print('第',i+1,'年终于还完了')

第 1 年还是要还钱
第 2 年还是要还钱
第 3 年还是要还钱
第 4 年还是要还钱
第 5 年还是要还钱
第 6 年还是要还钱
第 7 年还是要还钱
第 8 年还是要还钱
第 9 年还是要还钱
第 10 年还是要还钱
第 11 年还是要还钱
第 12 年还是要还钱
第 13 年还是要还钱
第 14 年还是要还钱
第 15 年还是要还钱
第 16 年还是要还钱
第 17 年还是要还钱
第 18 年还是要还钱
第 19 年还是要还钱
第 20 年还是要还钱
第 21 年还是要还钱
第 22 年还是要还钱
第 23 年还是要还钱
第 24 年还是要还钱
第 25 年还是要还钱
第 26 年还是要还钱
第 27 年还是要还钱
第 28 年还是要还钱
第 29 年还是要还钱
第 30 年还是要还钱
第 31 年终于还完了

第三章 函数和模块

3.1函数

1.函数概念

函数是一种语法结构，把一系列指令封装在一起
定义完毕后，就可以通过调用函数进行使用
输入数据被称为参数，参数能影响函数的行为

2.定义函数

首先制作一个函数
函数制作过程又称为定义函数(define function)
称这个函数为square_sum()
这个函数功能是计算两个数的平方和：

def square_sum(a,b):

	a = a**2
	b = b**2
	c = a + b
	return c

def这个关键字通知py“这里要定义函数了”
def后面跟着square_sum，即函数的名字。
在函数名后面还有个括号，用来说明函数有哪些参数
即括号中的a和b，参数可以有多个，也可以完全没有
根据py语法规定，即使没有输入数据，函数后面的括号也要保留

在定义函数时，使用了a和b两个符号来指代输入数据
等到真正使用函数时，才会说明a和b具体是什么样的数字
参数在函数定义定义的内部起到了和变量类似的功能
可以用符号化的形式参与到任何一行指令中
由于函数定义中的参数是个形式代表，并非真正数据
所以又称为形参(Parameter)

作为函数的最后一句，函数执行到return就会结束
不管它后面是否还有其他函数定义语句
如果把square_sum()改为下面形式：

def square_sum(a,b):

	a = a**2
	b = b**2
	c = a + b
	return c
	print('am I alive?')
	
则函数执行时，只会执行到return c
后面一句print()虽然也归属于函数，却不会被执行
所以，return还起到了终止函数和返回固定值的功能
在py语法中，return并不是必须的
如果没有return，或者return后面没有返回值时
则函数将返回None,None是py数据中的空数据
表示什么都没有
return也可以返回多个值
多个值跟在return后面，用逗号分隔
从效果上看，其等价于返回一个有多个数据的元组

return a,b,c     ＃相当于return(a,b,c)

3.调用函数

使用函数的过程叫做调用函数(Call Function)
在第一章中，已经调用过print()函数

print('Hello World')

直接使用了函数名，在括号中加入了具体参数
此时的参数不再是定义函数时使用的符号
而是一个实际的数据———字符串"Hello World"
所以，在函数调用时出现的参数称为实参(argument)

函数print()返回值为None
如果一个函数有其他返回值，那么可以获取这个返回值
一个常见的做法是把返回值赋予给变量

x = square_sum(3,4)
print(x)       ＃结果为25

py通过参数先后位置，知道3对应形参a
4对应形参b，然后把参数传递给函数square_sum()
函数执行内部语句，直到得出返回值25
再将25赋予给变量x，最后由print()打印出来

3.2基本传参

把数据用参数形式输入到函数，被称为参数传递
若有多个参数，那么在调用函数时
py会根据位置来确认数据对应哪个参数，例如：

def print_arguments(a,b,c)
	print(a,b,c)
print_arguments(1,3,5)    ＃打印1，3，5
print_arguments(5,3,1)    ＃打印5，3，1
print_arguments(3,5,1)    ＃打印3，5，1

在程序的三次调用中，py都是通过位置来确定实参与形参的对应关系的
如果觉得位置传参比较死板，那么可以用关键字(Keyword)的方式来传递参数
在定义函数时，我们给了形参一个符号标记，即参数名
关键字传递是根据参数名来让数据与符号对应上
因此，如果在调用时使用关键字传递，那么不用遵守位置的对应关系
沿用上面的函数定义，改用参数传递的方式：

print_arguments(c=5,b=3,a=1)   ＃打印1，3，5

位置传递与关键字传递可以混合使用，即一部分的参数传递根据位置，另一部分根据参数名
在调用函数时，所有的位置参数都要出现在关键字参数之前
因此，你可以用如下方式来调用：

print_arguments(1,c=5,b=3)     ＃打印1，3，5

print_arguments(c=5,1,b=3)     ＃程序报错

位置传递和关键字传递让数据与形参对应起来
因此数据个数与形参的个数应该相同
但在函数定义时，我们可以设置某些形参的默认值
如果我们在调用时不提供这些形参的具体数据
那么它们将采用定义时的默认值，比如：

def f(a,b,c=10):
	return a+b+c
print(f(3,2,1))     ＃参数c取传入的1，结果打印6
print(f(3,2))       ＃参数c取默认值10，结果打印15

第一次调用函数时输入了3个数据，正好对应三个形参
因此形参c对应的数据是1，第二次调用函数时
提供了3和2两个数据，函数根据具体位置，把3和2对应成形参a和b
到了形参c时，已经没有多余的数据，所以c将采用默认值10

2.包裹传参

以上传递参数的方式，都要求在定义函数时说明参数的个数。
但有时在定义函数时，并不知道参数的个数，其原因有很多
有时是确实不知道参数的个数，需要在程序运行时才知道
有时是希望函数定义更加松散，以便于函数能运用于不同形式的调用
这时候，用包裹(packing)传参的方式来进行参数传递会非常有用

包裹传参也有位置和关键字两种形式
下面是包裹传参的例子：

def package_position(*all_arguments):
	print(type(all_arguments))
	print(all_arguments)
package_position(1,4,6)
package_position(5,6,7,1,2,3)
<class 'tuple'>
(1, 4, 6)
<class 'tuple'>
(5, 6, 7, 1, 2, 3)

两次调用，尽管参数个数不同，但是都基于同一个package_position()定义
在调用package_position()时，所有数据都根据先后顺序，收集到一个元组
在函数内部，可以通过元组来读取传入数据，这就是包裹位置传参
为了提醒py参数all_arguments是包裹位置传递所用的元组名
我们在定义package_position()时要在元组名all_arguments前加上*号

再看包裹关键字传递的例子，这一参数传递方法把传入的数据收集为一个词典：

def package_keyword(**all_arguments):
	print(type(all_arguments))
	print(all_arguments)
package_keyword(a=1,b=9)
package_keyword(m=2,n=1,c=11)
<class 'dict'>
{'a': 1, 'b': 9}
<class 'dict'>
{'m': 2, 'n': 1, 'c': 11}

与上面一个例子相似，当函数调用时，所有参数会收集到一个数据容器里
只不过，在包裹关键字传递时，数据容器不再是一个元组
而是一个字典，每个关键字形式的参数调用，都会成为字典的一个元素。
参数名成为元素的键，而数据成为元素的值
字典all_arguments收集了所有的参数，把数据传递给函数使用
为了提醒，参数all_arguments是包裹关键字传递所用的字典
因此在all_arguments前加**

包裹位置传参还能与包裹关键字传参混合使用：

def package_mix(*positions,**keywords):
	print(positions)
	print(keywords)
package_mix(1,2,3,a=7,b=8,c=9)
(1, 2, 3)
{'a': 7, 'b': 8, 'c': 9}

还可以更进一步，把包裹传参和基本传参混合使用
它们出现的先后顺序是：位置->关键字->包裹位置->包裹关键字	
有了包裹传递，我们在定义函数时可以更灵活地表示数据

3.解包裹

除了用于函数定义，*和**还可以用于函数调用
这时候，两者是为了实现一种叫做解包裹(Unpacking)的语法
解包裹允许我们把一个数据容器传递给函数，再自动的分解为各个参数
需注意的是，包裹传参和解包裹并不是反向操作，而是两个相对独立的功能
下面是解包裹的一个例子：

def unpackage(a,b,c):
	print(a,b,c)
args = (1,3,4)
unpackage(*args)     ＃结果为1 3 4

在这个例子中，unpackage()使用了基本传参的方法
函数有三个参数，按照位置传递，但是在调用该函数时
我们用了解包裹的方式，可以看到，我们调用函数时传递的是一个元组
按照基本传参的方式，一个元组是无法和三个参数对应上的
但是我们通过在args前面加上*符号，来提醒py，我想把元组拆分成三个元素
每个元素对应函数的一个位置参数，于是，元组的三个元素分别被赋予了三个参数

相应的，词典也可用于解包裹，使用相同的unpackage()定义：

args = {'a':1,'b':2,'c':3}
unpackage(**args)     ＃打印1，2，3

解包裹用于函数调用，在调用时，几种参数传递方式也可以混合
依然是相同的基本原则：位置->关键字->包裹位置->包裹关键字	

3.3递归

1.高斯求和与数学归纳法

求1到100的和，用编程方法解决：

sum = 0
for i in range(1,101):
	sum = sum + i
print(sum)           ＃结果为5050

正如程序所显示，循环是解决问题的一个自然想法
但这并不是唯一方法，还可以用下面方式解题：

def gaussian_sum(n):
	if n == 1:
		return 1
	else:
		return n + gaussian_sum(n-1)
print(gaussian_sum(100))        ＃结果为5050

上面的解法使用了递归(Recursion)，即在一个函数定义中
调用了这个函数自身，为保证计算机不陷入死循环
递归要求程序有一个能够达到的终止条件(Base Case)
递归的关键是说明紧邻的两个步骤之间的衔接条件
比如我们已经知道1到51的累加和，即gaussian_sum(51)，
那么1到52的累加和就可以很容易的求得：
gaussian_sum(52) = gaussian_sum(51) + 52

使用递归设计程序的时候，我们从最终结果入手
即想要求得gaussian_sum(100)，计算机会把这个计算拆解为求得
gaussian_sum(99)以及gaussian_sum(99)加上100的运算。
以此类推，直到拆解为gaussian_sum(1)，就触发终止条件
也就是if结构中n = 1时，返回一个具体的数值1，尽管整个递归过程很复杂
但是在编写程序时，我们只需要关注初始条件，终止条件及衔接
而无需关注具体的每一步，计算机会负责具体的执行

2.函数栈

程序中的递归需要用到栈(Stack)这一数据结构，所谓数据结构，
是计算机存储数据的组织方式，栈是数据结构的一种，可以有序地存储数据

栈最显著的特征是“后进先出”(LIFO,Last In First Out)
当我们往箱子中存放一叠书时，先存放的书在箱底，后存放的书在箱顶
我们必须将后存放的书取出来，才能看到和拿出最开始存放的书
这就是“后进先出”，栈和这个装书的箱子类似，只能“后进先出”
每本书，也就是栈的每个元素，称为一个帧(frame)
栈只支持两个操作：pop和push，栈用弹出(pop)操作来取栈顶元素
用推入(push)操作将一个新的元素存入栈顶

正如我们前面所说，为了计算gaussian_sum(100)，我们需要先暂停
gaussian_sum(100)，开始计算gaussian_sum(99)，为了计算
gaussian_sum(99)，需要先暂停gaussian_sum(99)，计算
gaussian_sum(98)...,在触发终止条件前，会有很多次未完成的函数调用
每次函数调用时，我们在栈中推入一个新的帧，用来保存这次函数调用的相关信息
栈不断增长，直到计算出gaussian_sum(1)后，我们又会恢复计算
gaussian_sum(2)，gaussian_sum(3)...，由于栈“后进先出”的特点
所以每次只需要弹出栈的帧，就正好是我们所需要的gaussian_sum(2)，
gaussian_sum(3)，...直到弹出藏在最底层的帧gaussian_sum(100)

所以，程序运行的过程，可以看作是一个先增长栈后消灭栈的过程
每次函数调用，都伴随着一个帧入栈，如果函数内部还有函数调用，
那么又会多一个帧入栈，当函数返回时，相应的帧会出栈
等到程序的最后，栈清空，程序就完成了

3.变量作用域

有了函数栈的铺垫，变量的作用域就变简单了
函数内部可以创建新变量，如下面的一个函数：

def internal_var(a,b):
	c = a + b
	return c
print(internal_var(2,3))    ＃结果为5

事实上，py寻找变量的范围不止是当前帧，它还会寻找函数外部
也就是py主程序中定义了的变量，因此，在一个函数内部
我们能“看到”函数外部已经存在的变量，例如：

def inner_var():
	print(m)
m = 5
inner_var()         ＃结果为5

当主程序中已经有了一个变量，函数调用内部可以通过赋值的方式
再创建了一个同名变量，函数会优先使用自己函数帧中的那个变量
在下面的程序中，主程序和函数external_var()都有一个info变量
在函数external_var()内部，会优先使用函数内部的那个info：

def external_var():
	info = "Vamei's Python"
	print(info)      ＃结果为"Vamei's Python"
	
info = "Hello World"
external_var()
print(info)          ＃结果为"Hello World"

且函数内部使用的是自己内部的那一份，所以函数内部对info的操作不会
影响到外部变量info

函数的参数与函数内部变量类似，我们可以把参数理解为函数内部的变量
在函数调用时，会把数据赋值给这些变量，等到函数返回时
这些参数相关的变量会被清空，但也有特例，如下：

b = [1,2,3]
def change_list(b):
	b[0] = b[0] + 1
	return b
print(change_list(b))
print(b) 
[2, 2, 3]
[2, 2, 3]

我们将一个表传递给函数，函数进行操作后，函数外部的表b发生变化
当参数是一个数据容器时，函数内外部只存在一个数据容器
所以函数内部对该数据容器的操作，会影响到函数外部
这涉及到py的一个微妙机制，在第六章会对此进行深入探索

3.4 引入

1.引入模块

在py中，一个.py文件就构成了一个模块，通过模块，你可以调用其他文件中的函数
而引入(import)模块，就是为了在新程序中重复利用已有的py程序
对于面向过程语言来说，模块是比函数更高一层的封装模式
程序可以以文件为单位实现复用，典型的面向过程语言，如c语言
就有很完善的模块系统，把常见功能编到模块中，方便未来使用
就成了所谓的库(library)
由于py的库非常丰富，所以很多工作都可以通过引用库
即借助前人的工作来完成

2.搜索路径

py会在其他地方寻找库：
(1) 标准库的安装路径
(2) 操作系统环境变量PYTHONPATH所包含的路径
标准库是py官方提供的库，py会自动搜索标准库所在路径

如果是自定义模块，则可以放在自认为合适的地方
然后修改PYTHONPATH这个环境变量，当PYTHONPATH包含模块所在路径时
py便可以找到那个模块

3.5异常处理

1.bug

语法错误
运行时错误
语义错误

2.Debug

3.异常处理

对于运行时可能产生的错误，我们可以提前在程序中操作
这样做有两个可能的目的：
(1)让程序终止前进行更多的操作，比如提供更多关于错误的信息
(2)让程序在犯错后依然能运行下去

异常处理还能提高程序容错性，例如

while True:
	inputStr = input("Please input a number:")  ＃等待输入
	try:
		num = float(inputStr)
		print("Input number:",num)
		print("result:",10/num)
	except ValueError:
		print("Illegal input. Try Again.")
	except ZeroDivisionError:
		print("Illegal devision by zero. Try Again.")
		
Please input a number:2
Input number: 2.0
result: 5.0
Please input a number:-2
Input number: -2.0
result: -5.0
Please input a number:11
Input number: 11.0
result: 0.9090909090909091
Please input a number:-11
Input number: -11.0
result: -0.9090909090909091
Please input a number:0
Input number: 0.0
Illegal devision by zero. Try Again.
Please input a number:p
Illegal input. Try Again.
Please input a number:

需要异常处理的程序包裹在try结构中，而except说明了当特定错误发生时
程序该如何应对，程序中，input()是一个内置函数，用来接收命令行的输入
而float()函数则用于把其他类型的数据转换为浮点数
如果输入的是一个字符串，如“p”，则无法转换为浮点数
并触发ValueError，而相应的except就会运行隶属于它的程序
如果输入的是0，那么除法的分母为0，将触发ZeroDivisionError
这两种错误都是由预设的程序处理的，所以程序运行不会终止

如果没有发生异常，比如输入2，那么try部分正常运行，except部分被跳过
异常处理完整语法为：

try:
	...
except exception1:
	...
except exception2:
	...
else:
	...
finally:
	...
	
如果try中有异常发生时，将执行异常归属，执行except
异常层层比较，看是否是exception1，exception2...
直到找到其归属，执行相应except中的语句
如果try中没有异常，那么except部分跳过，执行else中的语句
finally是无论是否发生异常，最后都要做的事

如果except后面没有任何参数，那么表示所有的exception都交给这段程序处理
例如：

while True:
	inputStr = input("Please input a number:")
	try:
		num = float(inputStr)
		print("Input number:",num)
		print("result:",10/num)
	except:
		print("Something Wrong.Try Again.")
		
Please input a number:p
Something Wrong.Try Again.
Please input a number:2.5
Input number: 2.5
result: 4.0
Please input a number:3.5564
Input number: 3.5564
result: 2.8118321898549095
Please input a number:

如果无法将异常交给合适对象，那么异常将继续向上层抛
直到被捕捉或者造成主程序报错，例如：

def test_func()
	try:
		m = 1/0
	except ValueError:
	print("Catch ValueError in the sub-function")
try:
	test_func()
except ZeroDivisionError:
	print("Catch error in the main program")
	
Catch error in the main program

子程序的try...except...结构无法处理相应的除以0的错误
所以错误被抛给上层程序

第四章

4.1

1.面向对象语言(Object-Oriented-Language)的来历

要想了解面向对象，就要先来了解类(Class)和对象(Object)
还记得面向过程中的模块和函数吗，它们提高了程序的可复用性
类和对象同样提高了程序的可复用性，除此之外
类和对象这两种语法结构还加强了程序模拟真实世界的能力
“模拟”正是面向对象编程的核心

py也是一门面向对象语言，比java的历史更加悠久
只不过py允许程序员以纯粹面向过程的方式来使用它
所以人们有时会忽视它那颗面向对象的心

(c语言是面向结构也就是面向过程
面向结构，是把要实现的功能分成很多模块即函数
每个模块承担某一功能，每个模块可能会多次利用
这样就只需调用函数就行，不用重新定义，节省了代码和时间

面向对象，是我们把要实现的功能打包封装定义成一个类即一个对象
一个对象他既有多个属性也有多个行为，用类作为程序设计的单元
要实现这个类的功能还得把类实现，就是用类定义对象
就像面向结构里的函数定义后，你还得调用函数才能用函数的功能
类可以实现很多功能及对象的行为，也就是可以包含很多函数模块和变量
类与类直接可以通信也就是属性的传递就就是变量值的传递
这就比面向结构更加抽象，抽象级别更高。)

2.类

在日常生活中，我们把相似的东西归为一类，并且给这个类起一个名字
比如说，鸟类的共同属性事有羽毛，通过产卵生育后代
任何一只特别的鸟类都是建立在鸟类的原型基础上的

下面用py语言来记录上面的想法，描述鸟类：

class Bird(object):
	feather = True
	reproduction = 'egg'
	
在这里，我们用关键字class来定义一个类，类的名字就是鸟(Bird)
括号里有一个关键词object，也就是‘东西’的意思，即某个个体
在计算机语言中，我们把个体称为对象，一个类别下，可以有多个个体

冒号和缩进说明了属于这个类的代码，在隶属于这个类别的程序块中
我们定义了两个量，一个用于说明鸟类有羽毛(feather)
另一个用于说明鸟类的繁衍方式(reproduction)
这两个量称为类的属性(attribute)

我们除了用数据性的属性来分辨类别外，有时也根据这类东西能做什么事情区分
这样的一些行为属性称为方法(method)，py中
一般通过在类的内部定义函数来说明方法

class Bird(object):
	feather = True
	reproduction = 'egg'
	def chirp(self,sound):
		print(sound)

我们给鸟类新增一个方法属性，就是表示鸟叫的方法chirp()
方法chirp()看起来很像个函数，它的第一个参数是self
是为了在方法内部引用对象自身，（将在后面详细解释）
需要强调的是，无论该参数是否用到，方法的第一个参数必须是用于指代对象自身的self
剩下的参数sound是为了满足我们的需求设计的，它代表了鸟叫的内容
方法chirp()会把sound打印出来

3.对象

我们定义了类，但和函数定义一样，这还只是打造兵器的过程
为了使用这个利器，我们需要深入到对象的层面
通过调用类，我们可以创造出这个类下面的一个对象
比如说，我养了一只小鸟，叫summer，它是一个对象，且属于鸟类
我们使用前面已经定义好的鸟类，产生这个对象：

summer = Bird()

通过这一句创建对象，并说明summer是属于鸟类的一个对象
现在，我们就可以使用鸟类中已经写好的代码了
作为对象的summer将拥有鸟类的属性和方法
对属性的引用是通过对象.属性(object.attribute)的形式实现的
比如说：

print(summer.reproduction)   ＃打印'egg'

用上面的方式，我们得到summer所属类的繁衍方式

此外，我们还可以调用方法，让summer执行鸟类允许的动作，比如：

summer.chirp('jijiji')

在调用方法时，我们只传递了一个参数，也就是字符串'jijiji'
这正是方法与函数有所区别的地方，尽管在定义类的方法时
我们必须加上这个self参数，但self只能用在类定义的内部
所以在调用方法时不需要对self传入数据，通过chirp()方法
我的summer就可以叫了

到现在为止，描述对象的数据都储存于类的属性中
类属性描述了一个类的共性，比如，鸟类都有羽毛
所有属于该类的对象会共享这些属性，比如说
summer是一个鸟类的对象，因此summer也有羽毛
当然，我们可以通过某个对象来引用某个类属性

对于一个类下的全部个体来说，某些属性可能存在个体差异

因此，为了完整描述个体，除了共性的类属性外
我们还需要说明个性的对象属性，在类中，我们可以通过self来操作对象的属性
现在我们拓展Bird类：

class Bird(object):
	def chirp(self,sound):
		print(sound)
	def set_color(self,color):
		self.color = color
summer = Bird()
summer.set_color('yellow')
print(summer.color)         ＃打印yellow

在方法set_color()中，我们通过self参数设定了对象的属性color
和类属性一样，我们只能通过对象.属性的方式来操作对象属性
由于对象属性依赖于self，我们必须在某个方法内部才能操作类属性
因此，对象属性没办法像类属性一样，在类下方直接赋初值

但py还是提供了初始化对象属性的方法
py定义了一系列特殊方法，特殊方法又被称为魔法方法(Magic Method)
特殊方法的方法名很特别，前后有两个下划线，比如__init__()
__add__(),__dict__()等，程序员可以在类定义中设定特殊方法
py会以特定的方式来处理各个特殊方法，对于类的__init__()
py会在每次创建对象时自动调用，因此，我们可以在__init__()
方法内部来初始化对象属性：

class Bird(object):
	def __init__(self,sound):
		self.sound = sound
		print('my sound is:',sound)
	def chirp(self):
		print(self.sound)
summer = Bird('ji')
summer.chirp()

my sound is: ji
ji

在上面的类定义中，我们通过__init__()方法说明了这个类的初始化方式
每当对象建立时，比如创建summer对象时，__init__()方法就会被调用
它会设定这个对象的属性，在后面的chirp()方法中，就可以通过self调用这一对象属性
除了设定对象属性外，我们还可以在__init__()中加入其他指令
这些指令会在创建对象时执行，在调用类时，类后面可以跟一个参数列表
这里放入的数据将传给__init__()的参数，通过__init__()方法
我们可以在创建对象时就初始化对象属性

除了操作对象属性外，self参数还有另一个功能
就是能让我们在一个方法内部调用同一类的其他方法，比如：

class Bird(object):
	def chirp(self,sound):
		print(sound)
	def chirp_repeat(self,sound,n):
		for i in range(n):
			self.chirp(sound)
summer = Bird()
summer.chirp_repeat('ji',10)    ＃重复打印'ji'10次	

ji
ji
ji
ji
ji
ji
ji
ji
ji
ji

在方法chirp_repeat()中，我们通过self调用了类中的另一个方法chirp()

4.2

1. 子类

类别本身还可以进一步细化成子类，比如，鸟类可以进一步分成鸡，天鹅
在面向对象编程中，我们通过继承(Inheritance)来表达上述概念

class Bird(object):
	feather = True
	reproduction = 'egg'
	def chirp(self,sound):
		print(sound)
class Chicken(Bird):
	how_to_move = 'walk'
	edible = True
class Swan(Bird):
	how_to_move = 'swim'
	edible = False
summer = Chicken()
print(summer.feather)
summer.chirp('ji')
print(summer.how_to_move)

True
ji
walk

新定义的鸡(Chicken)类，增加了两个属性：移动方式(how_to_move)
和可以食用(edible)

在类定义时，括号里为Bird，这说明，鸡类是属于鸟类(Bird)的一个子类
即Chicken继承自Bird，子类Chicken将享有父类Bird的所有属性

2.属性覆盖

如上所述，在继承的过程中，我们可以在子类中增加父类不存在的属性，从而增强子类的功能
此外，我们还可以在子类中替换父类已经存在了的属性，如：

class Bird(object):
	def chirp(self):
		print('make sound')
class Chicken(Bird):
	def chirp(self):
		print('ji')
bird = Bird()
bird.chirp()
summer = Chicken()
summer.chirp()

make sound
ji

鸡类(Chicken)是鸟类(Bird)的子类，在鸡类(Chicken)中
我们定义了方法chirp()，这个方法在鸟类中也有定义
通过调用可以看出，鸡类会调用自己定义的chirp()方法
而不是父类中的chirp()方法，从效果上看，就好像父类中的方法
被子类中的同名属性覆盖(override)了一样

通过对方法的覆盖，我们可以彻底改变子类的行为，但有的时候
子类的行为是对父类行为的拓展，这时，我们可以通过super关键字
在子类中调用父类中被覆盖的方法，比如：

class Bird(object):
	def chirp(self):
		print('make sound')
class Chicken(Bird):
	def chirp(self):
		super().chirp()
		print('ji')
bird = Bird()
bird.chirp()
summer = Chicken()
summer.chirp()

make sound
make sound
ji

在鸡类的chirp()方法中，我们使用了super，它是一个内置类
能产生一个指代父类的对象，通过super，我们在子类的同名方法中调用了父类的方法
这样，子类的方法既能执行父类中的相关操作，又能定义属于自己的额外操作

调用super的语句可以出现在子类方法的第一句
也可以出现在子类方法的任意其他位置

4.3对象

1.列表对象

下面一些list方法，可以返回列表信息：

a = [1,2,3,5,9.0,'good',-1,True,False,'Bye']

>>>a.count(5)         ＃计数，看总共有多少个元素5     
>>>a.index(3)         ＃查询元素3第一次出现时的下标

对列表进行修改操作的方法：

>>>a.append(6)        ＃在列表的最后增添一个新元素6
>>>a.sort()           ＃排序
>>>a.reverse()        ＃颠倒次序
>>>a.pop()            ＃去除最后一个元素，并将该元素返回
>>>a.remove(2)        ＃去除第一次出现的元素2
>>>a.insert(0,9)      ＃在下标为0的位置插入9
>>>a.clear()          ＃清空列表

通过对方法的调用，列表的功能大为增强

2.元组和字符串对象

元组与列表一样，都是序列，但元组不能变更内容
因此，元组只能进行查询操作，不能进行修改操作：

a = (1,3,5)

>>>a.count(5)         ＃计数，看总共有多少个元素5     
>>>a.index(3)         ＃查询元素3第一次出现时的下标

字符串是特殊的元组，因此可以执行元组的方法：

a = 'abc'
a.index('c')

尽管字符串是元组的一种，但字符串(string)有一些方法能改变字符串
这似乎违背了元组的不可变性，其实，这些方法并不是修改字符串对象
而是删除原有字符串，再建立一个新的字符串，所以并没有违背元组的不可变性

下面总结了字符串对象的方法，str为一个字符串，sub为str的一个子字符串
s为一个序列，它的元素都是字符串，width为一个整数
用于说明新生成字符串的宽度，这些方法经常用于字符串的处理

str = 'Hello World!'
sub = 'World'

>>>str.count(sub)               ＃返回：sub在str中出现的次数

>>>str.find(sub)                ＃返回：从左开始，查找sub在str中第一次出现的位置
                                ＃如果str中不包含sub，返回－1

>>>str.index(sub)               ＃返回：从左开始，查找sub在str中第一次出现的位置
                                ＃如果str中不包含sub，举出错误

>>>str.rfind(sub)               ＃返回：从右开始，查找sub在str中第一次出现的位置
                                ＃如果str中不包含sub，返回－1

>>>str.rindex(sub)              ＃返回：从右开始，查找sub在str中第一次出现的位置
                                ＃如果str中不包含sub，举出错误

>>>str.isalnum()                ＃返回：True，如果所有的字符都是字母或数字

>>>str.isalpha()                ＃返回：True，如果所有的字符都是字母

>>>str.isdigit()                ＃返回：True，如果所有的字符都是数字

>>>str.istitle()                ＃返回：True，如果所有的词的首字母都是大写

>>>str.isspace()                ＃返回：True，如果所有的字符都是空格

>>>str.islower()                ＃返回：True，如果所有的字符都是小写字母

>>>str.isupper()                ＃返回：True，如果所有的字符都是大写字母

>>>str.split([sep,[max]])       ＃返回：从左开始，以空格为分隔符(separator)
                                ＃将str分割为多个子字符串，总共分割max次
                                ＃将所得的字符串放在一个表中返回，可以以
                                ＃str.resplit(',')的方式使用其他分隔符
                                
>>>str.rsplit([sep,[max]])      ＃返回：从右开始，以空格为分隔符(separator)
                                ＃将str分割为多个子字符串，总共分割max次
                                ＃将所得的字符串放在一个表中返回，可以以
                                ＃str.resplit(',')的方式使用其他分隔符

>>>str.join(s)                  ＃返回：将s中的元素，以str为分隔符
                                ＃合并成一个字符串

>>>str.strip([sub])             ＃返回：去掉字符串开头和结尾的空格
                                ＃也可以提供参数sub，去掉位于字符串开头和结尾的sub

>>>str.replace(sub,new_sub)     ＃返回：用一个新的字符串new_sub替换str中的sub

>>>str.capitalize()             ＃返回：将str第一个字母大写

>>>str.lower()                  ＃返回：将str全部字母改为小写

>>>str.upper()                  ＃返回：将str全部字母改为小写

>>>str.swapcase()               ＃返回：将str大写字母改为小写，小写字母改为大写

>>>str.title()                  ＃返回：将str的每个词(以空格分隔)的首字母大写

>>>str.center(width)            ＃返回：长度为width的字符串，将原字符串放入
                                ＃该字符串中心，其他空余位置为空格
                                
>>>str.ljust(width)             ＃返回：长度为width的字符串，将原字符串左对齐放入
                                ＃该字符串，其他空余位置为空格

>>>str.rjust(width)             ＃返回：长度为width的字符串，将原字符串右对齐放入
                                ＃该字符串，其他空余位置为空格
                                
3.词典对象

词典同样是一个类：

example_dict = {'a':1,'b':2}
type(example_dict)

我们可以通过词典的keys()方法，来循环遍历每个元素的键：

for k in example_dict.keys():
	print(example_dict[k])
	
通过values()方法，可以遍历每个元素的值，或者用items方法
直接遍历每个元素：

for v in example_dict.values():
	print(v)
	
for k,v in example_dict.items():
	print(k,v)
	
1
2
a 1
b 2

我们也可以用clear方法，清空整个词典：

example_dict.clear()   ＃清空example_dict,变为{}

4.4

1.循环对象

py中的许多语法结构都是由对象实现的，循环就可以通过对象实现
循环对象并不是在py诞生之初就存在的，但它的发展极为迅速
特别是在py3时代，循环对象正是成为循环的标准形式

那么，什么是循环对象呢？所谓的循环对象包含有一个__next__()方法
这个方法的目的是生成循环的下一个结果，在生成过循环的所有结果之后
该方法将抛出StopIteration异常

当一个像for这样的循环语法调用循环对象时，它会在每次循环的时候
调用__next__()方法，直到StopIteration循环出现
循环接受到这个异常，就会知道循环已经结束，将停止调用__next__()

我们用内置函数iter()把一个列表转变为循环对象
这个循环对象将拥有__next__()方法，我们多次调用__next__()方法
将不断返回列表的值，直到出现异常：

example_iter = iter([1,2])
example_iter.__next__()    ＃显示1
example_iter.__next__()    ＃显示2
example_iter.__next__()    ＃出现StopIteration异常

我们上面重复调用__next__()的过程，就相当于手动进行了循环
我们可以把循环对象包裹在for中自动进行循环：

for item in iter([1,2])
	print(item)

在这里，for结构自动调用了__next__()方法，将该方法的返回值赋予给item
循环知道出现StopIteration的时候结束，当然，我们可以省去内置函数iter的转换
这是因为，for结构会自动执行这一转换

相对于序列，循环对象的好处在于：不用在循环还没开始的时候
就生成要使用的元素，所有要使用的元素可以在循环过程中逐渐生成
这样，不仅节省了空间，提高了效率，还会使编程更加灵活

我们可以借助生成器(generator)来自定义循环对象
生成器的编写方法和函数定义类似，只是在return的地方改为yield
生成器中可以有多个yield，当生成器遇到一个yield时
会暂停运行生成器，返回yield后面的值，当再次调用生成器的时候
会从刚才暂停的地方继续运行，直到下一个yield
生成器自身又构成一个循环对象，每次循环使用一个yield返回的值

def gen():
	a = 100
	yield a
	a = a*8
	yield a
	yield 1000

该生成器共有三个yield，如果用作循环对象时，会进行三次循环

for i in gen():
	print(i)
	
100
800
1000

再考虑下面一个生成器：

def gen():
	i = 0
	while i < 10000000:
		i = i + 1
		yield i
		
这个生成器能产生10000000个元素，如果先创建序列保存这10000000个元素
再循环遍历，那么这个序列将占用大量空间，出于同样原因
py中的内置函数range()返回的是一个循环对象，而不是一个序列

for i in range(10000000):
	print('hello world')  ＃打印10000000遍hello world
	
2.函数对象

前面说过，在py中，函数也是一种对象，中、实际上，任何一个有__call__()
特殊方法的对象都被当作是函数，例如：

class SampleMore(object):
	def __call__(self,a):
		return a + 5
add_five = SampleMore()        ＃生成函数对象
print(add_five(2))             ＃像一个函数一样调用函数对象，结果为7

add_five为SampleMore类的一个对象，当被调用时，add_five执行加5的操作

3.模块对象

前面说过，py中的模块对应一个.py文件，模块也是对象
比如，我们直接引入标准库的模块time：

import time
print(dir(time))

['_STRUCT_TM_ITEMS', '__doc__', '__loader__', '__name__', '__package__', '__spec__',
'altzone', 'asctime', 'clock', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 
'localtime', 'mktime', 'monotonic', 'perf_counter', 'process_time', 'sleep',
'strftime', 'strptime', 'struct_time', 'time', 'timezone', 'tzname', 'tzset']

可以看到，time有很多属性可以调用，例如sleep()方法
我们之前用import语句引入其他文件中定义的函数
实际上就是引入模块对象的属性，比如：

from time import sleep
sleep(10)
print('wake up')

模块time的sleep()会中止程序，调用时的参数说明给了中止的时间

我们还可以用简单暴力的方法，一次性引入模块的所有属性：

from time import *
sleep(10)

既然知道了sleep()是time的一个方法
那么我们当然可以利用对象属性的方式来调用它

import time
time.sleep(10)

我们在调用方法时附带上了对象名，这样做的好处是可以拓展程序的命名空间
避免同名冲突，例如，如果两个模块中都有sleep()方法，
那么我们可以通过不一样的模块名来区分开，在my_time.py中写入函数：

def sleep(self):
	print('I am sleeping')

在main.py中引入内置模块和自定义模块my_time：

import time
import my_time

time.sleep()
my_time.sleep()

上面的两次对sleep()方法的调用中，我们分别通过对象名区分出了不同的sleep()

在引入模块时，我们还可以给模块换个名字：

import time as t
t.sleep(10)

在引入名字比较长的模块时，这个换名字的方法更加方便快捷

可以将功能相似的模块放在同一个文件夹中，构成一个模块包
比如放在this_dir中：

import this_dir.module

引入this_dir文件夹中的module模块
该文件夹中必须包含一个__init__.py的文件，提醒py，该文件夹为一个模块包
__init__.py可以是一个空文件
每个模块对象都有一个__name__属性，用来记录模块的名字，例如：

import time
print(time.__name__)

当一个.py文件作为主程序运行时，比如python foo.py
这个文件也会有一个对应的模块对象
但这个模块对象的__name__属性会是“__main__”
因此，我们在很多.py文件中可以看到下面的语句：

if __name__ == "__main__":
	...

它的意思是说，如果这个文件作为一个主程序运行，那么将执行下面的操作
有的时候，一个.py文件中同时有类和对象的定义，以及对它们的调用
当这些.py文件作为库引入时，我们可能并不希望执行这些调用
通过把调用语句放到上面的if中，就可以在调用时不执行这些语句

4.异常对象

前面我们提到过，可以在程序中加入异常处理的try结构，捕捉程序中出现的异常
实际上，我们捕捉到的也是一个对象，比如

try:
	m = 1/0
except ZeroDivisionError as e:
	print("Catch NameError in the sub-function")

print(type(e))     ＃类型为'exceptions.ZeroDivisionError'
print(dre(e))      ＃异常对象的属性
print(e.message)   ＃异常信息integer division or modulo by zero

利用except...as...的语法，我们在except结果中用e来代表捕捉到的类型对象
关键字except直接跟随ZeroDivisionError实际上是异常对象的类
正因为如此，我们在举出异常时会创建一个异常对象：

raise ZeroDivisionError()

在py中，循环，函数，模块，异常都是某种对象
当然，我们可以完全按照面向过程中的方式来调用这些语法
而不必关注它们底层的对象模型，但是出于学习的目的
这些语法结构的对象模型能加深我们对py的理解

第五章

5.1存储

1.文件

我们知道，py中的数据都保存在内存中，当电脑断电时，就好像患了失忆症
内存中的数据就会消失，另一方面，如果py程序运行结束
那么分配给这个程序的内存空间也会清空，为了长期持续地存储
py必须把数据存储在磁盘中，这样，即使断电或程序结束
数据依然存在

磁盘以文件为单位来存储数据，对于计算机来说，数据的本质就是
有序的二进制数序列，如果以字节为单位，也就是每8位二进制数序列为单位
那么这个数据序列就称为文本，这是因为，8位的二进制数序列正好
对应ASCII编码中的一个字符，而py能够借助文本对象来读写文件

在py中，我们可以通过内置函数open来创建文件对象
在调用open时，需要说明文件名，以及打开文件的方式：

f = open(文件名，方式)

文件名是文件存在于磁盘的名字，打开文件的常用方式有：

"r"   ＃读取已经存在的文件
"w"   ＃新建文件，并写入
"a"   ＃如果文件存在，那么写入到文件的结尾，如果文件不存在，则新建文件并写入

例如：

f = open("test.txt","r")

就是用只读的方式，打开了一个名为test.txt的文件

通过返回上面的对象，我们可以读取文件：

content = f.read(10)        ＃读取10个字节的数据
content = f.readline()      ＃读取一行
content = f.readlines()     ＃读取所有行，储存在列表中，每个元素是一行

如果以"w"或"a"方式打开，那么我们就可以写入文本：

f = open('test.txt','w')
f.write('i like apple')     ＃将'i like apple'写入文件

如果想写入一行，则需要在字符串末尾加上换行符
在UNIX系统中，换行符为"\n"
在windows系统中，换行符为"\r\n"

打开文件端口将占用计算机资源，因此，在读写完成后
应该及时的用文件对象的close()方法关闭文件：

f.close()

用法延伸：
r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式

rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头

r+：以读写方式打开一个文件。文件指针将会放在文件的开头

rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头

w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。

wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。

w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。

wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。

a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。
也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。

ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。
也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。

a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。
文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。

ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。
如果该文件不存在，则创建新文件用于读写。

来源链接：https://juejin.im/post/5ab22accf265da239a5fb172

2.上下文管理器

文件操作常常和上下文管理器一起使用，上下文管理器(context manager)
用于规定某个对象的使用范围，一旦进入或者离开该使用范围，则会有特殊操作被调用
比如为对象分配或者释放内存，上下文管理器可用于文件操作，对于文件操作来说
我们需要在读写结束时关闭文件，程序员经常会忘记关闭文件，无谓占用资源
上下文管理器可以在不需要文件的时候，自动关闭文件

下面时一段常规的文件操作程序：

＃常规文件操作

f = open("new.txt","w")
print(f.closed)            ＃检查文件是否打开
f.write("hello world!")
f.close()
print(f.closed)            ＃打印True

如果我们加入上下文管理器的语法，就可以把程序改写为：

＃使用上下文管理器

with open("new.txt","w") as f:
	f.write("hello world!")
print(f.closed)

第二段程序就使用了with...as...结构，上下文管理器有隶属于它的程序块
当隶属的程序块执行结束时，也就是语句不再缩进时，上下文管理器就会自动关闭文件
在程序中，我们调用了f.closed属性来验证是否已经关闭
通过上下文管理器，我们相当于用缩进来表达文件对象的打开范围
对于复杂的程序来说，缩进的存在能让程序员更清楚的意识到文件在哪些阶段打开
减少忘记关闭文件的可能性

上面的上下文管理器基于f对象的__exit__()特殊方法
使用上下文管理器的语法时，py会在进入程序块之前调用文件对象的__enter__()方法
在结束程序块的时候调用文件对象的__exit__()方法
在文件对象的__exit__()中，有self.close()语句
因此，在使用上下文管理器时，我们就不必用明文关闭文件了

任何定义了__enter__()方法和__exit__()的对象都可以用于上下文管理器
下面，我们自定义一个类Vow,并定义它的__enter__()方法和__exit__()方法
因此，由Vow类的对象可以用于上下文管理器：

class Vow(object):
	def __init__(self,text):
		self.text = text
	def __enter__(self):
		self.text = "i say:" + self.text    ＃增加前缀
		return self                         ＃返回一个对象
	def __exit__(self,exc_type,exc_value,traceback):
		self.text = self.text + "!"         ＃增加后缀
with Vow("I'm fine") as myVow:
	print(myVow.text)
	
print(myVow.text)

i say:I'm fine
i say:I'm fine!

初始化对象时，对象的text属性是"I'm fine"我们可以看到
在进入上下文和离开上下文时，对象调用了__enter__()方法和__exit__()方法
从而造成对象的text属性改变

__enter__()返回一个对象，上下文管理器会使用这一对象作为as所指变量
我们自定义的__enter__()返回的是self，也就是新建的Vow类对象本身
在__enter__()中，我们为text属性增加了前缀"i say:"
在__exit__()中，我们为text属性增加后缀"!"

值得注意的是，__exit__()有四个参数，当程序块中出现异常时
__exit__()参数中exc_type,exc_value,traceback用于描述异常
我们可以根据这三个参数进行相应的处理，如果正常运行结束，则这三个参数都是None

3.pickle包

我们能把文本存于文件，但py中最常见的是对象，当程序结束或者计算机关闭时
这些存在于内存的对象会消失，那么，我们能否把对象保存在磁盘上呢

利用pickle包就可以做到这一点，英文里，pickle是腌菜的意思
大航海时代的海员们常把蔬菜做成腌菜，装在罐头里带着走
py中的pickle也有类似的意思，通过pickle包，我们可以把某个对象保存下来
再存成磁盘里的文件

实际上，对象的存储分为两步，第一步，我们将对象在内存里的数据直接抓取出来
转换成一个有序的文本，即所谓的序列化(Serialization),第二步
将文本存入文件，等到需要时，我们从文件中读出文本，再放入内存
就可以获得原有的对象，下面是一个具体的例子
首先是第一步序列化，将内存中的对象转换为文本流：

import pickle
class Bird(object):
	have_feather = True
	reproduction_method = 'egg'
summer = Bird()                          ＃创建对象
pickle_string = pickle.dumps(summer)     ＃序列化对象

使用pickle包的dumps()方法可以将对象转换成字符串的形式
随后，我们用字节文本的存储方法，将该字符串储存在文件
继续第二步

with open("summer.pkl","wb") as f:
	f.write(pickle_string)
	
上面程序故意分成了两步，以便更好的展示整个过程
其实，我们可以使用dump()的方法，一次完成两步：

import pickle

class Bird(object):
	have_feather = True
	reproduction_method = 'egg'
summer = Bird()                 
with open("summer.pkl","wb") as f:
	pickle.dump(summer,f)         ＃有序化并保存对象
	
对象summer将存储在文件summer.pkl中
有了这个文件，我们就可以在必要的时候读取对象了
读取对象与存储对象的过程正好相反，首先，我们从文件中读取文本
然后使用pickle的loads()方法，将字符串形式的文本转换为对象
我们也可以使用pickle的load()方法，将上面两步合并

有的时候，仅仅是反向恢复还不够，对象依赖于它的类
所以py在创建对象时，需要找到相应的类
因此当我们从文本中读取对象时，程序中必须已经定义过类
对于py总是存在的内置类，如列表，词典，字符串等
不需要再在程序中定义，但是对于用户自定义的类，就必须要先定义类
然后才能在文件中载入该类的对象
下面是一个读取对象的例子：

import pickle

class Bird(object):
	have_feather = True
	reproduction_method = 'egg'
summer = Bird()                 
with open("summer.pkl","rb") as f:
	summer = pickle.load(f)
print(summer.have_feather)       ＃打印True  

5.2

1.time包

计算机可以用来计时，从硬件上来说，计算机主板上有一个计时的表
我们可以手动或者根据网络时间来调表，这块表有自己的电池
所以即使断电，表也不会停，在硬件基础上
计算机可以提供__挂钟时间__(Wall Clock Time)
挂钟时间是从某个固定时间起点到现在的时间间隔
对于UNIX系统来说，起点时间是1970年1月1日0点0分0秒
其他日期时间都是从挂钟时间计算得到的，此外
计算机还可以测量CPU实际运行时间，也就__处理器时间__(Processor Clock Time)
以测量计算机性能，当CPU处于闲置状态时，处理器时间会暂停

我们能通过py编程来管理时间和日期，标准库time包提供了基本的时间功能
下面使用time包：

import time
print(time.time())     ＃挂钟时间，单位是秒

还能借助模块time测量程序运行时间，比如：

import time
start = time.clock()
for i in range(100000):
	print(i**2)
end = time.clock()
print(end - start)       ＃打印19.904038，即CPU运行时间

上面的程序调用了两次clock()方法，从而测量镶嵌其间的程序所用的时间
在不同的计算机系统上，clock()的返回值会有所不同，在UNIX系统上
返回的是处理器时间，当CPU处于闲置状态时，处理器时间会暂停
因此我们获得的是CPU运行时间，在windows系统上，返回的则是挂钟时间 

方法sleep()可以让程序休眠，根据sleep()接受到的参数
程序会在某时间间隔之后醒来继续运行：

import time
print("start")
time.sleep(10)     ＃休眠10秒
print("wake up")

time包还定义了struct_time对象，该对象将挂钟时间转换为年，月，日，时，分，秒等
储存在该对象的各个属性中，比如tm_year,tm_mon,tm_mday......
下面几种方法可以将挂钟时间转换为struct_time对象：

st = time.gmtime()           ＃返回struct_time格式的UTC时间

st = time.localtime()        ＃返回struct_time格式的当地时间，当地时区根据系统环境决定

我们也可以反过来，把一个struct_time对象转换为time对象：

s = time.mktime(st)          ＃将struct_time格式转换成挂钟时间

2.datetime包

datetime包是基于time包的一个高级包，用起来更加便利
datetime可以理解为date和time两个部分组成
date是指年月日构成的日期，相当于日历，time是指时分秒毫秒
构成的一天24个小时中的具体时间，提供了与手表类似的功能
因此，datetime模块下有两个类：datetime.date类和datetime.time类
你也可以把日历和手表合在一起使用，即直接调用datetime.datetime类
这里只介绍综合性的datetime.datetime类，单独的datetime.date类和datetime.time类与之类似

一个时间点，比如2012年9月3日21时30分，我们可以用如下方式表达：

import datetime

t = datetime.datetime(2012,9,3,21,30)
print(t)

2012-09-03 21:30:00

对象t具有如下属性：
hour,minute,second,millisecond,microsecond
小时，分，秒，毫秒，微秒
year,month,day,weekday
年，月，日，星期几

借助datetime包，我们还可以进行时间间隔的运算
它包含一个专门代表时间间隔对象的类，即timedelta
一个datetime.datetime的时间点加上一个时间间隔
就可以得到一个新的时间点，比如今天的上午3点加上5个小时
就可以得到一个时间间隔：

import datetime

t = datetime.datetime(2012,9,3,21,30)
t_next = datetime.datetime(2012,9,5,23,30)
delta1 = datetime.timedelta(seconds = 600)
delta2 = datetime.timedelta(weeks = 3)

print(t + delta1)        ＃打印2012-09-03 21:40:00
print(t + delta2)        ＃打印2012-09-24 21:30:00
print(t_next - t)        ＃打印2 days, 2:00:00

在给datetime.timedelta传递参数时，除了上面的秒(seconds)
和星期(weeks)外，还可以是天(days)，小时(hours)，毫秒(milliseconds)
微秒(microseconds)

两个datetime对象能进行比较运算，以确定哪个时间间隔更长
比如使用的t和t_next：

print(t>t_next)          ＃打印False

3.时间格式

对于包含有时间信息的字符串来说，我们可以借助datetime包
把它转换为datetime类的对象，比如：

from datetime import datetime

str = "output-1997-12-23-030000.txt"
format = "output-%Y-%m-%d-%H%M%S.txt"
t = datetime.strptime(str,format)
print(t)                 ＃打印1997-12-23 03:00:00

包含有时间信息的字符串是"output-1997-12-23-030000.txt"
是一个文件名，字符串format定义了一个格式
这个格式中包含了几个由%引领的特殊字符，用来代表不同时间信息
%Y表示年份，%m表示月，%d表示日，%H表示24小时制的小时，%M表示分，%S表示秒
通过strptime方法，py会把需要解析的字符串往格式上凑
比如说，在格式中%Y的位置，正好看到"1997",就认为1997是datetime对象t的年
以此类推，就从字符串中获得了t对象的时间信息

反过来，我们也可以调用datetime对象的strftime方法
将一个datetime对象转换为特定格式的字符串，比如：

from datetime import datetime

format = "%Y-%m-%d %H:%M"
t = datetime(2012,9,5,23,30)
print(t.strftime(format))     ＃打印2012-09-05 23:30

可以看到，格式化转化的关键是％号引领的特殊符号
这些特殊符号有很多种，分别代表不同的时间信息，常用的特殊符号还有：

%A：表示英文的星期几，如Sunday,Monday...
%a：简写的英文星期几，如Sun,Mon...
%I：表示小时，12小时制
%p：上午或者下午，即AM或PM
%f：表示毫秒，如2，0014，000001

但如果想在格式中表达％这个字符本身，而不是特殊符号，那么可以使用％％

5.3

1.正则表达式

正则表达式(Regular Expression)的主要功能是从字符串(string)
中通过特定的模式，搜索希望找到的内容
前面，我们已经简单的介绍了字符串对象的一些方法
我们可以通过这些方法来实现简单的搜索功能
例如，从字符串'i love you'中搜索'you'这一子字符串
但有些时候，我们只是想要找到符合某种格式的字符串，而不是具体的'you'
类似的例子还有很多，比如说找到小说中所有的人名
再比如说想找到字符串中包含的数字
这种格式化的搜索可以写成正则表达式
py中可以使用包re来处理正则表达式
下面是一个简单的应用，目的是找到字符串中的数字：

import re

m = re.search('[0-9]','abcd4ef')
print(m.group(0))

re.search()接收两个参数，第一个参数'[0-9]'就是我们所说的正则表达式
它告诉py，‘我想从字符串中找从0到9的任意一个数字字符’

re.search()如果从第二个参数中找到符合要求的子字符串
就返回一个对象m，你可以通过m.group()的方法查看搜索到的结果
如果没有找到符合要求的字符，则re.search()会返回None

除了search()方法外，re包还提供了其他搜索方法，它们的功能有所差别：

m = re.search(pattern,string)   ＃搜索整个字符串，直到发现符合的子字符串 
m = re.match(pattern,string)    ＃从头开始检查字符串是否符合正则表达式
                                ＃必须从字符串的第一个字符开始就符合

我们可以从这两个函数中选择一个进行搜索，上面的例子，如果使用re.match()
则会得到None，因为字符串的起始为'a'，不符合'[0-9]'的要求

我们还可以在搜索之后将搜索到的子字符串进行替换
下面的sub()利用正则pattern在字符串string中进行搜索
对于搜索到的字符串，用另一个字符串replacement进行替换
函数将返回替换后的字符串：

str = re.sub(pattern,replacement,string)

此外，常用的方法还有

re.split()        ＃根据正则表达式分割字符，将分割后的所有子字符串
                  ＃放在一个表(list)中返回
re.findall()      ＃根据正则表达式搜索字符串，将所有符合条件的自字符串
                  ＃放在一个表(list)中返回
                  
2.写一个正则表达式

正则表达式的功能其实非常强大，关键在于如何写出有效的正则表达式
我们先看正则表达式的常用语法，正则表达式用某些符号代表单个字符：

.         ＃任意的一个字符

a|b       ＃字符a或字符b

[afg]     ＃a或者f或者g的一个字符

[0-4]     ＃0-4范围内的一个字符

[a-f]     ＃a-f范围内的一个字符

[^m]      ＃不是m的一个字符

\s        ＃一个空格

\S        ＃一个非空格

\d        ＃一个数字，相当于[0-9]

\D        ＃一个非数字，相当于[^0-9]

\w        ＃数字或字母，相当于[0-9a-zA-Z]

\W        ＃非数字非字母，相当于[^0-9a-zA-Z]

正则表达式还可以用某些符号来表示某种形式的重复
这些符号紧跟在单个字符之后，就表示多个这样类似的字符：

*       ＃重复0次或更多次

+       ＃重复1次或者超过1次

?       ＃重复0次或1次

{m}     ＃重复m次，比如，a{4}相当于aaaa，再比如，[1-3]{2}相当于[1-3][1-3]

{m,n}   ＃重复m到n次，比如，a{2,5}表示a重复2到5次
        ＃小于m次或大于n次的重复都不符合条件

下面是重复符号的例子：

正则表达        相符的字符串举例       不相符的字符串举例
[0-9]{3,5}        '9678'           '1,2','1234567'
a?b             'b','ab'             'cb'
a+b             'aaaaab'             'b'

最后，还有位置相关的符号：

^     ＃字符串的起始位置

$     ＃字符串的结尾位置

下面是位置符号的一些例子：
正则表达        相符的字符串举例       不相符的字符串举例
^ab.*c$        abeec                cabeec

3.进一步提取

有的时候，我们想在搜索的同时，对结果进一步提炼
比如说，我们从下面一个字符串中提取信息：

content = 'abcd_output_1994_abcd_1912_abcd'

如果我们把正则表达式写成：

'output_\d{4}'

那么用search()方法可以找到'output_1994'
但是如果我们想进一步提取出1994本身，则可以在正则表达式上给目标加上括号：

output_(\d{4})

括号()包围了一个小的正则表达式\d{4},这个小的正则表达式能从结果中进一步筛选信息
即四位的阿拉伯数字，用括号()圈起来的正则表达式的一部分，称为群(group)
一个正则表达式中可以有多个群

我们可以group(number)的方法来查询群，需要注意的是
group(0)是整个正则表达的搜索结果，group(1)是第一个群，以此类推：

import re 

m = re.search('output_(\d{4})','output_1986.txt')
print(m.group(0))
print(m.group(1))

output_1986
1986

我们还可以将群命名，以便更好的使用group查询：

import re

m = re.search('output_(?P<year>\d{4})','output_1986.txt')

print(m.group('year'))     ＃打印1986

上面的(?P<year>...)括住了一个群，并把它命名为year
用这种方式来产生群，就可以通过'year'这个键来提取结果。

第七章
函数式编程
 
7.1
 
1.Python中的函数式
 
函数式编程强调了函数的纯粹性(purity)
一个纯函数是没有副作用的(Side Effect),即这个函数的运行不会影响其他函数
为了达到纯函数标准，函数式编程要求其变量都是不可变更的
 
py并非完全的函数式编程语言，在py中，存在着可变更的对象，也能写出非纯函数
但如果我们借鉴函数式编程，尽量在编程中避免副作用，就会有许多好处
由于纯函数相互独立，我们不必担心函数调用对其他函数的影响
所以使用起来更加简单，另外，纯函数也方便进行并行化运算
在并行化编程时，我们经常担心不同进程之间相互干扰的问题
当多个进程同时修改一个变量时，进程的先后顺序会影响最终结果
如下面两个函数：
 
from threading import Thread
 
x = 5
 
def double():
	global x
	x = x*2

def plus_ten():
	global x
	x = x + 10

thread1 = Thread(target=double)
thread2 = Thread(target=plus_ten)
thread1.start()
thread2.start()
thread1.join()
thread2.join()

print(x) 

20

上面两个函数中使用了关键字global
global说明了x是一个全局变量
函数对全局变量的修改能被其他函数看到，因此也有副作用
如果两个进程并行地执行两个函数，函数的执行顺序不确定
则结果可能是double()中的x = x*2先执行，最终结果为20
也有可能是plus_ten()中的x = x + 10先执行，最终结果为30
这被称为竞跑条件(Race Condition)，是并行编程中需要极力避免的

from threading import Thread
 
x = 5
 
def double():
	global x
	x = x*2

def plus_ten():
	global x
	x = x + 10

thread1 = Thread(target=double)
thread2 = Thread(target=plus_ten)
thread2.start()
thread1.start()
thread1.join()
thread2.join()

print(x) 

30

函数式编程消灭了副作用，即无形中消除了竞跑条件的可能性
因此，函数式编程天生适用于并行化运算

2.并行运算

上一节中，我们已经涉及到并行运算，所谓并行运算，是指多条指令同时执行
一般来说，一台单处理器计算机同一时间只能执行一条指令
这种每次执行一条指令的工作方式称为串行运算

大规模并行运算通常是在有多个主机组成的集群(Cluster)上进行的
主机之间可以借助高速的网络设备通信，一个集群造价不菲
然而，我们可以在单机上通过多进程或多线程的方式
模拟多主机的并行处理，即使一台单机中，也往往存在着多个运行中的程序
即所谓的进程，例如：我们在打开浏览器上网的同时
还可以流畅的听音乐，这给我们一个感觉，计算机在并行的进行上网和放音乐两个任务
事实上，单机的处理器按照‘分时复用’的方式，把计算能力分配给多个进程
处理器在进程间频繁切换，因此，即使处理器同一时间只能处理一个指令
但通过在进程间的切换，也能造成多个进程齐头并进的效果

从这个角度来说，集群和单机都实现了多个进程的并行运算
只不过，集群上的多进程分布在不同的主机，而单机的多进程存在于同一主机
并借着‘分时复用’来实现并行

下面是多进程编程的例子：

import multiprocessing

def proc1():
	return 999999**9999
def proc2():
	return 888888**8888
p1 = multiprocessing.Process(target=proc1)
p2 = multiprocessing.Process(target=proc2)

p1.start()
p2.start()

p1.join()
p2.join()

上面程序用了两个进程，进程的工作包含在函数中，分别是函数proc1()和函数proc2()
方法start()用于启动进程，而join()方法用于在主程序中等待相应进程完成

最后，我们要区分一下多进程和多线程，一个程序运行后
就成为一个进程，进程有自己的内存空间，用来存储自身的运行状态，数据和相关代码
一个进程一般不会直接读取其他进程的内存空间
进程运行过程中，可以完成程序描述的工作
但一个进程内部，又可以有多个称为‘线程’的任务
处理器可以在多个线程之间切换，从而形成并行的多线程处理
线程看起来和进程类似，但线程之间可以共享同一个进程的内存空间

7.2

1.函数作为参数和返回值

在函数式编程中，函数是第一级对象，所谓‘第一级对象’
即函数能像普通对象一样来使用，因此，函数的使用变得更加自由
对于‘一切皆对象’的py来说，这是自然而然的结果
既然如此，那么函数可以像一个普通对象一样，成为其他函数的参数
比如下面的程序，函数就充当了参数：

def square_sum(a,b):
	return a**2 + b**2
def cubic_sum(a,b):
	return a**3 + b**3
def argument_demo(f,a,b):
	return f(a,b)

print(argument_demo(square_sum,3,5))    ＃打印34
print(argument_demo(cubic_sum,3,5))     ＃打印152

函数argument_demo()的第一个参数f就是一个函数对象
按照位置传参，square_sum()传递给函数argument_demo()
对应参数列表中的f，f会在argument_demo()中被调用，我们可以把其他函数
如cubic_sum()作为参数传递给argument_demo()

很多语言都能把函数作为参数使用，例如C语言，在图形化界面编程时
这样一个作为参数的函数经常起到回调(Callback)的作用
当某个事件发生时，比如界面上的一个按钮被按下，回调函数就会被调用
下面是一个GUI回调的例子：

import tkinter as tk

def callback()
	"""
	callback function for button click
	"""
	listbox.insert(tk.END,"hello world!")

if __name__ == "__main__":
	master = tk.Tk()
	button = tk.Button(master,text = "OK",command=callback)
	button.pack()
	
	listbox = tk.Listbox(master)
	list.pack()
	tk.mainloop()
	
py内置了tkinter的图形化功能，在上面的程序中
回调函数将在列表栏中插入"hello world!"
回调函数作为参数传给按钮的构造器
每当按钮被点击时，回调函数就会被调用

2.函数作为返回值

既然函数是一个对象，那么它就可以成为另一个函数的返回结果

def line_conf():
	def line(x):
		return 2*x+1
	return line     ＃返回一个函数表达式

my_line = line_conf()
print(my_line(5))   ＃打印11

上面的代码可以成功运行，line_conf()的返回结果被赋给line对象
上面的代码将打印11

在上面的例子中，我们看到了在一个函数内部定义的函数
和函数对象一样，函数对象也有存活范围，也就是函数对象的作用域
py的缩进形式很容易让我们看到函数对象的作用域
函数对象的作用域与它的def的缩进层级相同，比如下面的代码
我们在line_conf()函数的隶属范围内定义的函数line()
就只能在line_conf()的隶属范围内调用

def line_conf():
	def line(x):
		return 2*x+1
	print(line(5))       ＃作用域内
 
if __name__ == "__main__":
	line_conf()
	print(line(5))       ＃作用域外，报错
	
11
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-d80d15301af2> in <module>()
      6 if __name__ == "__main__":
      7     line_conf()
----> 8     print(line(5))

NameError: name 'line' is not defined

函数line()定义了一条直线(y=2x+1)，可以看到
在line_conf()中可以调用line()函数
而在作用域之外调用line()函数将会有下面的错误：

NameError: name 'line' is not defined

这说明已经超出了函数line()的作用域，py对该函数的调用失败

3.闭包

上面函数中，line()定义嵌套在另一个函数内部
如果函数的定义中引用了外部变量，会发生什么呢？

def line_conf():
	b = 15
	def line(x):
		return 2*x + b
	b = 5
	return line       ＃返回函数对象

if __name__ == '__main__':
	my_line = line_conf()
	print(my_line(5))  ＃打印15
	
可以看到，line()定义的隶属程序块中引用了高层级的变量b
b的定义并不在line()的内部，而是一个外部对象
我们称b为line()的环境变量，尽管b位于line()定义的外部
但当line被函数line_conf()返回时，还是会带有b的信息

一个函数的它的环境变量合在一起，就构成了一个闭包(Closure)
上面程序中，b分别在line()定义的前后有两次不同的赋值
上面的代码将打印15，也就是说，line()参照的是值为5的b值
因此，闭包中包含的是内部函数返回时的外部对象的值

在py中，所谓闭包是一个包含有环境变量取值的函数对象
环境变量取值被复制到函数对象的__closure__属性中
比如下面代码：

def line_conf():

	b = 15
	def line(x):
		return 2*x + b
	b = 5
	return line        ＃返回函数对象

if __name__ == '__main__':
	my_line = line_conf()
	print(my_line.__closure__)
	print(my_line.__closure__[0].cell_contents)
	
(<cell at 0x1074379a8: int object at 0x10268f5d0>,)
5
	
可以看到，my_line()的__closure__属性中包含了一个元组
这个元组中的每个元素都是cell类型的对象
第一个cell包含的就是整数5，也就是我们返回闭包时的环境变量b的取值

闭包可以提高代码的可复用性，下面看四个函数：

def line1(x):
	return x + 1
def line2(x):
	return 4*x + 1
def line3(x):
	return 5*x + 10
def line4(x):
	return -2*x - 6
	
如果把上面的程序改为闭包，那么代码就会简单很多：

def line_conf(a,b):
	def line(x):
		return a*x + b
	return line
	
line1 = line_conf(1,1)
line2 = line_conf(4,5)
line3 = line_conf(5,10)
line4 = line_conf(-2,-6)

这个例子中，函数line()与环境变量a,b构成闭包
在创建闭包的时候，我们通过line_conf()的参数说明直线的参量
这样，我们就能复用同一个闭包，通过代入不同的数据来获得不同的直线函数
如y=x+1和y=4x+5，闭包实际上创建了一群形式相似的函数

除了复用代码，闭包还能起到减少函数参数的作用：

def curve_closure(a,b,c):
	def curve(x):
		return a*x**2 + b*x + c
	return curve
curve1 = curve_closure(1,2,1)

函数curve()是一个二次函数，它除了自变量x外
还有a,b,c三个参数，通过curve_closure()这个闭包
我们可以预设a,b,c三个参数，从而起到减参的效果

闭包的减参作用对于并行运算来说很有意义
在并行运算环境下，我们可以让每台电脑负责一个函数
把上一台电脑的输出和下一台电脑的输入串联起来
最终，我们像流水线一样工作，由于每台电脑只能接受一个输入
所以在串联之前，必须用闭包之类的方法把参数的个数降为1

7.3

1.装饰器

装饰器(decorator)是一种高级py语法，装饰器可以对一个函数，方法或者类进行加工
在py中，我们有多种方法对函数和类进行加工，装饰器从操作上入手
为函数增加额外的指令，py最初没有装饰器这一语法
装饰器在py2.5中才出现，最初只用于函数
在py2.6以及之后的py版本中，装饰器被进一步用于类

我们先定义两个简单的数学函数，一个用来计算平方和
一个用来计算平方差：

＃获得平方和
def square_sum(a,b):
	return a**2 + b**2  

＃获得平方差
def square_diff(a,b):
	return a**2 - b**2
	
if __name__ == '__main__':
	print(square_sum(3,4))    ＃打印25
	print(square_diff(3,4))   ＃打印－7
	
在拥有了基本的数学功能之后，我们可能想为函数增加其他的功能
比如打印输入，我们可以改写函数来实现这一点：

＃装饰：打印输入

def square_sum(a,b):
	print('input:',a,b)
	return a**2 + b**2

def square_diff(a,b):
	print('input:',a,b)
	return a**2 - b**2
	
if __name__ == '__main__':
	print(square_sum(3,4))
	print(square_diff(3,4))
	
我们修改了函数定义，为函数增加了功能，从代码中可以看到
这两个函数在功能上的拓展有很高的相似性
都是增加了print('input:',a,b)这一打印功能
我们可以改用装饰器，定义功能拓展本身
再把装饰器用于两个函数：

def decorator_demo(old_function):
	def new_function(a,b):
		print('input',a,b)    ＃额外打印操作
		return old_function(a,b)
	return new_function

@decorator_demo
def square_sum(a,b):
	return a**2 + b**2
	
@decorator_demo
def square_diff(a,b):
	return a**2 - b**2

if __name__ == '__main__':
	print(square_sum(3,4))
	print(square_diff(3,4))
	
装饰器可以用def的形式定义，如上面代码中的decorator_demo()
装饰器接受一个可调用的对象作为输入参数，并返回一个新的可调用对象
装饰器新建了一个函数对象，也就是上面的new_function()
在new_function()中，我们增加了打印的功能
并通过调用old_function(a,b)来保留原有函数的功能

定义好装饰器后，我们就可以通过@语法使用了
在函数square_sum()和square_diff()定义之前
调用@decorator_demo，实际上是将square_sum()
或square_diff()传递给了decorator_demo()
并将decorator_demo()返回的新的函数对象赋给原来的函数名
square_sum()和square_diff()
所以当我们调用square_sum(3,4)的时候，实际上发生的是：

square_sum = decorator_demo(square_sum)
square_sum(3,4)

我们知道，py中的变量名和对象是分离的
变量名其实是指向一个对象的引用
从本质上，装饰器起到的作用就是名称绑定(name binding)
让同一个变量名指向一个新返回的函数对象，从而达到修改函数对象的目的
只不过，我们很少彻底更改函数对象，在使用装饰器时
我们往往会在新函数内部调用旧的函数，以便保留旧函数功能

下面看一个更有实用功能的装饰器，我们可以利用time包来测量程序运行的时间
把测量程序运行时间的功能做成一个装饰器，将这个装饰器运用于其他函数
将显示函数的实际运行时间：

import time

def decorator_timer(old_function):
	def new_function(*arg,**dict_arg):
		t1 = time.time()
		result = old_function(*arg,**dict_arg)
		t2 = time.time()
		print('time:',t2 - t1)
		return result
	return new_function

@decorator_timer
def sum(a,b):
    c = a + b
    return c
if __name__ == '__main__':
    print(sum(3,4))
    
time: 1.1920928955078125e-06
7

在new_function()中，除调用旧函数外
还前后额外调用了一次time.time()，由于time.time()返回挂钟时间
它们的差值反映了旧函数的运行时间，此外，我们通过打包参数的方法
可以在新函数和旧函数之间传递所有的参数

装饰器可以实现代码的可复用性，我们可以用同一个装饰器修饰多个函数
以便实现相同的附加功能，比如说，在建设网站服务器时，我们能用不同函数
表示对不同HTTP请求的处理，当我们每次处理HTTP请求前
都想附加一个客户验证功能时，那么就可以定义一个统一的装饰器
作用于每一个处理函数，这样，程序能重复利用，可读性也大为提高

Python中的函数的参数定义和可变参数
https://www.cnblogs.com/tqsummer/archive/2011/01/25/1944416.html

2.带参装饰器

在上面的装饰器调用中，比如@decorator_demo
该装饰器默认它后面的函数是唯一的参数
装饰器的语法允许我们调用decorator时，提供其他参数
比如@decorator(a)，这样，就为装饰器的编写和使用提供了更大的灵活性

#带参装饰器

def pre_str(pre=""):
	def decorator(old_function):
		def new_function(a,b):
			print(pre + "input",a,b)
			return old_function(a,b)
		return new_function
	return decorator
	
#装饰square_sum()
@pre_str("^_^")
def square_sum(a,b):
	return a**2 + b**2   
	
#装饰square_diff()
@pre_str("T_T")
def square_diff(a,b):
	return a**2 - b**2

if __name__ == '__main__':
	print(square_sum(3,4))
	print(square_diff(3,4))
	
^_^input 3 4
25
T_Tinput 3 4
-7

	
上面的pre_str是一个带参装饰器，它实际上是对原有装饰器的一个函数封装
并返回一个装饰器，我们可以将它理解为一个含有环境参量的闭包
当我们使用@pre_str("^_^")调用的时候，py能够发现这一层的封装
并把参数传递到装饰器的环境中，该调用相当于：

square_sum = pre_str("^_^")(square_sum)

根据参数不同，带参装饰器会对函数进行不同的加工，进一步提高了装饰器的适用范围
还是以网站的用户验证为例子，装饰器负责验证的功能，装饰了处理HTTP请求的函数
可能有的关键HTTP请求需要管理员权限，有的只需要普通用户权限
因此，我们可以把“管理员”和“用户”作为参数，传递给验证装饰器
对于那些负责关键HTTP请求的函数，我们可以把“管理员”参数传给装饰器
对于负责普通HTTP请求的函数，我们可以把“用户”参数传给它们的装饰器
这样，同一个装饰器就可以满足不同的需求了

3.装饰类

在上面的例子中，装饰器接收一个函数，并返回一个函数
从而起到加工函数的效果，装饰器还拓展到了类
一个装饰器可以接收一个类，并返回一个类，从而起到加工类的效果

def decorator_class(SomeClass):
	class NewClass(object):
		def __init__(self,age):
			self.total_display = 0
			self.wrapped = SomeClass(age)
		def display(self):
			self.total_display += 1
			print('total display',self.total_display)
			self.wrapped.display()
	return NewClass

@decorator_class
class Bird:
	def __init__(self,age):
		self.age = age
	def display(self):
		print('my age is',self.age)
		
if __name__ == '__main__':
	eagle_lord = Bird(5)
	for i in range(3):
		eagle_lord.display()

total display 1
my age is 5
total display 2
my age is 5
total display 3
my age is 5
		
在装饰器decorator_class中，我们返回了一个新类NewClass
在新类的构造器中，我们用一个属性self.wrapped记录了原来类生成的对象
并附加了新的属性total_display，用于记录调用display()的次数
我们也同时更改了display方法，通过装饰
我们的Bird类可以调用display()的次数
无论是装饰函数，还是装饰类，装饰器的核心作用都是名称绑定
虽然装饰器出现较晚，但在各个py项目中的使用却很广泛
即便不需要自定义装饰器，你也很有可能会在自己的项目中调用其他库中的装饰器
因此，py程序员需要掌握这一语法

7.4高阶函数

1.lambda与map

前面提到了，函数能像一个普通对象一样应用，从而成为其他函数的参数和返回值
能接收其他函数作为参数的函数，被称为高阶函数(high-order function)
前面介绍的装饰器，本质上就是高阶函数
高阶函数是函数式编程的一个重要组成部分
下面介绍最具有代表性的高阶函数：map()，filter()和reduce()

首先引入一种新的定义函数的方式，我们已经见过很多用def来定义函数的例子
除了def，还可以用lambda语法来定义匿名函数，例如：

lambda_sum = lambda x,y: x + y
print(lambda_sum(3,4))

通过lambda，我们创建了一个匿名的函数对象，借着赋值语句
这个匿名函数赋予给函数名lambda_sum，函数的参数为x,y
返回值为x和y的和，函数lambda_sum()的调用与正常函数一样
这种用lambda来产生匿名函数的方式适用于简短函数的定义

现在我们来看高阶函数，所谓高阶函数，就是能处理函数的函数
在前面，我们就已经见过了函数对象参数
接收函数对象为参数的函数，就是高阶函数
py中提供了很多有用的高阶函数，我们从map()开始介绍
函数map()是py的内置函数，它的第一个参数就是一个函数对象
函数map()把这一个函数对象作用于多个元素：

data_list = [1,3,5,6]
result = map(lambda x: x+3,data_list)

函数map()的第二个参数是一个可循环对象，对于data_list的每个元素
lambda函数都会调用一次，那个元素会成为lambda函数的参数
换个角度说，map()把接收到的函数对象依次作用于每个元素
最终，map()会返回一个迭代器，迭代器中的元素
就是多次调用lambda函数的结果，因此上面的代码相当于：

def equivalent_generator(func,iter):
	for item in iter:
		yield func(item)
		
data_list = [1,3,5,6]
result = map(lambda x:x+3,data_list)

上面的lambda函数只有一个参数，这个函数也可以是一个多参数的函数
这个时候，map()的参数列表中就需要提供相应数目的可循环对象

def square_sum(x,y):
	return x**2 + y**2
	
data_list1 = [1,3,5,7]
data_list2 = [2,4,6,8]
result = map(square_sum,data_list1,data_list2)

这里，map()接收了square_sum()作为第一个参数
函数square_sum()要求有两个参数
因此，map()调用时需要两个可循环对象
第一个循环对象提供了square_sum()中对应于x的参数
第二个循环对象提供了square_sum()中对应于y的参数
关系如图所示：

一定程度上，map()函数能替代循环的功能
用map()函数写出的程序，看起来也相当简洁
从另一个角度来说，map()看起来像是对多个目标“各个击破”
在并行运算中，Map是一个很重要的过程
通过Map这一步，一个大问题可以拆分成很多小问题
从而能交给不同的主机处理
例如在图像处理中，就可以把一张大图分拆成许多张小图
每张小图分配给一台主机处理

		
 









	































































































































































































































































































